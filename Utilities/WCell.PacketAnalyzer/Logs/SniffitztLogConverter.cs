using System;
using System.IO;
using System.Linq;
using NLog;
using WCell.Constants;
using WCell.Core.Network;
using WCell.PacketAnalysis.Updates;
using WCell.Util;

namespace WCell.PacketAnalysis.Logs
{
    /// <summary>
    /// A converter for Log-files, using the format that is generated by the Sniffitzt-logger.
    /// See: http://sharesource.org/project/sniffitzt/
    /// </summary>
    public class SniffitztLogConverter
    {
        protected static Logger log = LogManager.GetCurrentClassLogger();

        public static SniffitztLog Load(string file)
        {
            return SniffitztLog.Load(file);
        }

        public static void Extract(string logFile, OpCodeValidator validator, Action<ParsablePacketInfo> parser)
        {
            Extract(logFile, new LogHandler(validator, parser));
        }

        /// <summary>
        /// Extracts all Packets out of the given logged and default-formatted lines
        /// </summary>
        public static void Extract(string logFile, params LogHandler[] handlers)
        {
            var logXml = Load(logFile);

            var packets = logXml.Packets;

            for (var i = 0; i < packets.Length; i++)
            {
                var pckt = packets[i];
                var opCode = (RealmServerOpCode)pckt.Opcode;
                var opcodeHandlers = handlers.Where(handler => handler.Validator(opCode)).ToList();
                if (opcodeHandlers.Count() <= 0) continue;
                var timestamp = Utility.GetUTCTimeSeconds(pckt.Date);
                var bytes = UpdateFieldsUtil.HexStringConverter.ToByteArray(pckt.Value);

                if (!Enum.IsDefined(typeof(RealmServerOpCode), opCode))
                {
                    log.Warn("Packet #{0} had undefined Opcode: " + opCode, i);
                    continue;
                }

                var rawPacket = DisposableRealmPacketIn.Create(opCode, bytes);
                if (rawPacket == null) continue;
                packets.Initialize();
                // UNCOMMENT TO GET PARTICULAR PACKETS PARSED
                //if (paket.PacketID.ToString().Contains("_QUEST")){
                foreach (var handler in opcodeHandlers)
                {
                    handler.PacketParser(new ParsablePacketInfo(rawPacket, pckt.Sender, timestamp));
                }
                //}
            }
        }

        /// <summary>
        /// Renders the given log file to the given output.
        /// </summary>
        /// <param name="logFile">The log file.</param>
        /// <param name="output">A StreamWriter or Console.Out etc</param>
        public static void ConvertLog(string logFile, TextWriter output)
        {
            var writer = new IndentTextWriter(output);
            Extract(logFile, LogConverter.DefaultValidator, info =>
            {
                LogConverter.ParsePacket(info, writer);
            });
        }

        public static void ConvertLog(string logFile, string outputFile)
        {
            using (var stream = new StreamWriter(outputFile, false))
            {
                ConvertLog(logFile, stream);
            }
        }
    }
}