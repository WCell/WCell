using System;
using System.IO;
using System.Linq;
using WCell.Util.Logging;
using WCell.Constants;
using WCell.Core.Network;
using WCell.PacketAnalysis.Updates;
using WCell.Util;

namespace WCell.PacketAnalysis.Logs
{
	/// <summary>
	/// A converter for Log-files, using the format that is generated by the Sniffitzt-logger.
	/// See: http://sharesource.org/project/sniffitzt/
	/// </summary>
	public class SniffitztLogConverter
	{
		protected static Logger log = LogManager.GetCurrentClassLogger();

		public static SniffitztLog Load(string file)
		{
			return SniffitztLog.Load(file);
		}

		public static void Extract(string logFile, OpCodeValidator validator, Action<ParsablePacketInfo> parser)
		{
			Extract(logFile, new LogHandler(validator, parser));
		}

		/// <summary>
		/// Extracts all Packets out of the given logged and default-formatted lines
		/// </summary>
		public static void Extract(string logFile, params LogHandler[] handlers)
		{
			var logXml = Load(logFile);

		    var packets = logXml.Packets;

			for (var i = 0; i < packets.Length; i++)
			{
				var pckt = packets[i];
				var opCode = (RealmServerOpCode)pckt.Opcode;
				var opcodeHandlers = handlers.Where(handler => handler.Validator(opCode));
				if (opcodeHandlers.Count() > 0)
				{
					var timestamp = Utility.GetUTCTimeSeconds(pckt.Date);
					var bytes = UpdateFieldsUtil.HexStringConverter.ToByteArray(pckt.Value);

					if (!Enum.IsDefined(typeof (RealmServerOpCode), opCode))
					{
						log.Warn("Packet #{0} had undefined Opcode: " + opCode, i);
						continue;
					}

					var rawPacket = DisposableRealmPacketIn.Create(opCode, bytes);
					if (rawPacket != null)
					{
						packets.Initialize();
						// UNCOMMENT TO GET PARTICULAR PACKETS PARSED
						//if (paket.PacketID.ToString().Contains("_QUEST")){
						foreach (var handler in opcodeHandlers)
						{
							handler.PacketParser(new ParsablePacketInfo(rawPacket, pckt.Sender, timestamp));
						}
					}
				}
				//}
			}
		}

		/// <summary>
		/// Renders the given log file to the given output.
		/// </summary>
		/// <param name="logFile">The log file.</param>
		/// <param name="output">A StreamWriter or Console.Out etc</param>
		public static void ConvertLog(string logFile, TextWriter output)
		{
			var writer = new IndentTextWriter(output);
			Extract(logFile, LogConverter.DefaultValidator, info => {
				LogConverter.ParsePacket(info, writer);
			});
		}

		public static void ConvertLog(string logFile, string outputFile)
		{
			using (var stream = new StreamWriter(outputFile, false))
			{
				ConvertLog(logFile, stream);
			}
		}
	}
}